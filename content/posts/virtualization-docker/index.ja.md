---
weight: 4
title: "Dockerを完全に理解する"
date: 2025-04-30T00:00:00+09:00
lastmod: 2025-04-30T00:00:00+09:00
draft: false
author: "しぶや"
authorLink: "https://github.com/shibuya-s-eg"
description: "Dockerを完全に理解する。"
images: []
resources:
- name: "featured-image"
  src: "featured-image.png"

tags: ["Virtualization"]
categories: ["Virtualization"]

lightgallery: true
---

こんにちは、しぶやです。\
学生時代の研究から始まり、社会人になってからも愛用しているDockerについて、気合をいれてまとめようと思います。

## TL;DR

*
*
*

## 0　はじめに

### 0.1　コンテナの歴史

コンテナ技術の初期段階として、2008年ごろLXC（Linux Container）が登場しました。
LXCは、2000年代に入ってLinuxに導入されたNamespaceやCgroupsを利用した軽量なコンテナ環境を提供するものです。

その後、2013年ごろ、Dockerが登場し、コンテナ技術が広く知られるようになりました。
DockerはLXCをもとに、コンテナの作成、管理、デプロイを非常に簡単にするツールとして登場しました。
Dockerの登場により、コンテナは非常に使いやすいものとなり、仮想マシンに代わる新しい標準として急速に普及しました。

※ Dockerはあくまでコンテナを管理するためのツールであり、Docker=コンテナではないです。

公式ではDockerを以下のように説明しています。
> Docker は、アプリケーションの開発、出荷、実行の方法に革命をもたらした包括的なプラットフォームとツールスイートを提供します。
> コンテナ化の概念に基づいて構築されており、コンテナの代名詞になるほど単純化されています。

コンテナという意味では近年、Kubernetesにより大規模な分散システムの基盤として使用されたり、サーバーレスコンピューティングに応用されていたりします。

### 0.2　VMとの違い

VMとコンテナの違いはよく聞く話だと思います。
[よくある説明](https://www.redhat.com/ja/topics/containers/containers-vs-vms)は、ホストOS上に新たにOSを乗せるているかとホストOS上にコンテナとして隔離されたアプリケーションを乗せているかです。

この説明の通り、**VMとコンテナの違いはホストのカーネルを共有するか**です。
VMはホストOS上でカーネルを仮想化を行います。
一方で、コンテナはホストのカーネルを共有し、リソースなどを分離します。

これにより、コンテナは**軽量なアプリケーションの実行環境**を実現します。

## 1　コンテナの仕組み

コンテナにはいくつかの欠かせない要素技術があります。
本章では、コンテナの本質を理解するために、それらの要素技術について学習しようと思います。

### 1.1　namespace

NamespaceはLinuxカーネルに組み込まれたプロセス単位でリソースを分離する機能です。
具体的には、特定のプロセスに対し、ネットワークインターフェースを見せたり、プロセスID空間を見せたりできます。

linuxでサポートされているNamespaceには以下のよいなものがあります。
|名前 | 分離対象 | 説明|
|-----------|-------|-----|
|Mount (mnt) | ファイルシステムのマウント状態 | それぞれ別のルートディレクトリ構造を持てる|
|UTS|ホスト名、ドメイン名|各Namespaceごとにホスト名が持てる|
|IPC|プロセス間通信（共有メモリなど）|通信空間を隔離できる|
|PID|プロセスID|プロセスID空間が分かれる|
|Network|ネットワークデバイス、IPアドレス|独立したネットワークスタック|
|User|ユーザID、グループID|プロセスに別のUID/GIDマッピング|
|Cgroup|cgroupのビュー|制御グループの空間を分離|

では、実際にNamespaceを見てみましょう。

{{< image src="lsns.png" width="800px" height="600px" caption="Namespaceの一覧" >}}

lsnsはNamespaceを表示するためのコマンドです。
TYPEが上で紹介したNamespaceの種類です。
NPROCSはそのNamespaceに所属するプロセス数、PID以降は親プロセスの情報です。

ここで、"sudo lsns"と"lsns"で表示されているNamespaceの数が違うことが分かります。

これは、rootでしかアクセスできないプロセスがいるためです。
よく見るとNPROCSの値も異なることが解ると思います。
Namespaceの情報は各プロセスが持つので、ユーザでは一部のNamespaceの所属するすべてのプロセスが見えず、Namespaceを確認することができないのです。

実際に、/proc配下のアクセス権限を見るとユーザではみれないものがいることが分かります。
（Linuxではプロセス情報はLinuxカーネルが提供する/procから取得しています。）

{{< image src="proc-visibility.png" width="800px" height="600px" caption="/procのアクセス権" >}}


unshare utsコマンド

"unshare"コマンドは新しいNamespaceでプログラムを実行できます。
すなわち、親プロセスである現在のshell(私の場合はzsh)からNamespaceを継承せずに子プロセスを作成することができます。

今回の例では、新しいUTS Namespaceを持つshellのプロセスを作成しています。
この場合、新しく作成したプロセス内でhostnameを変更しても、shellが認識しているUTS Namespaceとホスト側の
が認識していUTS Namespaceが異なるため、ホスト側からhostnameコマンドを打っても特に変化はありません。

unshare psコマンド

プロセスID空間を分離していますが、ホストのプロセス全体が見えています。
これは、psコマンドは/procを見てるだけだからです。
ホストからpsコマンドでアクセスする際と何も変わりません。

コンテナの動きを考えると、プロセスID空間が分離され、新しいプロセスからは何も見えない状況となって欲しいところです。
これを実現するには、1.3のchrootを利用する必要があります。

unshare mountコマンド

mount namespaceはプロセスにファイルシステムのマウントポイントをバインドし実行するコマンドです。
そもそもプロセスへのマウントとは何でしょうか？
Linuxにおいて各プロセスはファイルシステムのマウントポイントを持っています。
通常は全て同じ"/"がマウントポイントとしてバインドされているはずです。
これは、/proc/${pid}/mountsで見ることができます。

プロセスのmountの写真

プロセスごとにマウントポイントを持っていることが分かります。

先ほどのunshare --mountコマンドではshを起動していますが、マウントポイントがであるため、それより上の階層にはアクセスできません。




### 1.2　cgroup

CgroupはLinuxカーネルに組み込まれたプロセス単位でリソースを監視/制御する機能です。
具体的には以下のようなことができます。

* リソース使用量のモニタリング
* CPU使用率の制限
* メモリ使用量の制限
* ディスクI/O帯域の制限
* ネットワーク帯域の制限

Cgroupはプロセスをグループにまとめたプロセスグループを作成し、リソース管理のルールを適用することでリソース使用量の管理／制御を行います。

Dockerはコンテナ単位でCgroupのグループを作成し、リソース使用量を管理しているのです！

それでは実際にCgroupを見ていきましょう。

/sys/fs/cgroupの写真

Linuxカーネルは/sys/fs/cgroupに擬似ファイルシステムを作成し、Cgroupに関連する情報を提供します。

tip 擬似ファイルシステムとは

擬似ファイルシステムとは、実際にファイルのようにカーネル内部の情報にアクセスできるようにする仕組みです。
実際にディスク内部にデータを保存しているわけではなく、リアルタイムにカーネルが情報を生成して応答してくれています。
カーネルAPIみたいな感じですね、

Linuxの擬似ファイルシステムのは以下のようなものがあります。
* /proc\
プロセス情報やシステム情報をふぁいるけいしきで提供
* /sys\
デバイスやカーネル内部設定の情報/操作をファイル形式で提供
* /dev\
デバイスファイル

一例挙げる


cgroup実践




docker起動時のcgroupの確認

メモリ
cpu
process


### 1.3　chroot/rootfs

chrootはrootディレクトリを変更するコマンドです。
chrootは引数にパスとコマンドを受け取ります。
これにより、指定したパスをルートとして、コマンドを実行します。
ここで、注意が必要なのは、コマンド自身もルートより上位のファイルにはアクセスできなくなります。
すなわち、ルートとして指定したパスの配下にコマンド実行に必要なファイルが一式必要です。

実際に、適当なコマンドで試してみましょう。


配下にechoの実行ファイルがないため、エラーになります。

では、よりdockerを意識してalpineのパッケージを使って試してみましょう。

配下にalpineのパッケージが一式あるため、コマンドを実行できます。
shを実行してみるとルートより上には上がれず、一式のファイルがあるため仮想環境のように感じます。
まさにDockerでコンテナを立てたときのようですね！
＊ chroot時はホストの環境変数は引き継がれ、$pathなどはルートとして設定された位置を起点に検索が行われます。

tip 環境変数
chrootではホストの環境変数が引き継がれていましたが、dockerで立てたコンテナではホストとは隔離されて別の環境変数が利用できます。
これはどのように実現されているのでしょうか？

これを理解するためには、そもそも環境変数の理解が必要です。
実は、環境変数の実体はメモリ上に保存されており、プロセスごとに保持しています。

プロセスがもつ環境変数の例
/proc/$$/environ

のプロセスが環境変数を持っていることが分かります。

確認したように、環境変数はプロセスごとに保持してお、プロセスは他プロセスの環境変数にアクセスすることはできません。
子プロセスは親プロセスの環境変数を引き継ぎ、親プロセスの環境変数のは影響を与えずに自身の環境変数を変更できます。

dockerなどでは、コンテナを生成する際にメインプロセスに引数やDockerfike、コンテナイメージから受け取った環境変数を付与し、コンテナを立ち上げます。


1.1との組み合わせ。


### 1.4　コンテナの本質

コンテナはプロセス。
initプロセスとPID
ホストから見たとき

## 2　コンテナイメージ

### 2.1　イメージ管理

コンテナレジストリとは、コンテナイメージ全体の保管サーバです。
代表的なレジストリには以下があります。
* Docker Hub...Docker者が運営する、最も有名なパブリックレジストリ
* Github Container Registry...Githubが提供するコンテナレジストリ
* Amazon ECR...AWSが提供するマネージドなレジストリ（AzureやGCPも同様）

コンテナレジストリに対し、レジストリ内の特定の名前空間/プロジェkとごと保存単位をレポジトリと呼びます。
Docker Hubにある公式の"nginx:latest"を例にするとDocker Hubがレジストリであり、nginxがレポジトリ名です。

ここでは、Dockerでデフォルトで利用されるDocker Hubについて調査します。

[Docker Hub](https://www.docker.com/ja-jp/products/docker-hub/)はコンテナ化されたアプリを簡単に保存、管理、デプロイするためのプラットフォームです。
Docker Hubの機能には以下のようなものがあります。
* 無制限のパブリックリポジトリ...無制限のパブリックなリポジトリを利用できます。誰かが作成したカスタムイメージなどもすぐに利用できます。
* プライベート リポジトリ...プライベートリポジトリを作成し、イメージへのアクセス制御を行うことができます。
* 効率的なイメージアクセス...コンテナイメージへの効率的なアクセスと配布をサポート
* Webhook...イメージのプッシュなどのイベントをトリガーに外部に通知を送ることができます。これにより、Docker HubのCI/CDパイプラインとの統合を可能にします。
* 自動テスト...コンテナイメージで自動テストを実行し、問題を早期に発見することができます。
* GitHubとBitbucketの統合...Githubなどと統合し、バージョン管理システムからの直接ビルドと導入を自動化します。
* 同時ビルドと自動ビルド...複数のビルドを同時に実行することができます。


### 2.2　イメージの構成

Layerの階層構造
再利用性
Union FS


### 2.3　最小化

scratch, Alpine, distroless
思想
attack surfaceの削減
運用

## 3　コンテナセキュリティ

### 3.1　capability

管理者権限を与えずに、最小権限の原則に則り、動作に必要な権限のみを与えるやつです。
以下は「Linuxのアクセス制御を完全に理解する」からの抜粋です。

>

基本的なアクセス制御から復習したい方は「Linuxのアクセス制御を完全に理解する」をお勧めします！

### 3.2　コンテナroot

コンテナ内のrootは？
ユーザ変える必要ある？
--privileged

### 3.3　イメージ

信頼性
Docker Content Trust

## 4　Dockerのユースケースとアーキテクチャ

### 4.1　CI/CD


### 4.2　Kubernetes

### 4.3　環境統一


## 5　Dockerのメリット/デメリット

### 5.1　メリット

環境構築の迅速化
環境の再現性と移植性
リソースの軽量性
ホストを汚さない
アタックサーフェスの削減

### 5.2　デメリット

セキュリティ境界の脆弱性
ホスト依存の可能性
オーバーヘッド

## 6　まとめ

kubernetes thread model
kunernetes atacck tree

hoge

## 参考

[1] [docker](https://www.docker.com/)
[2] [コンテナセキュリティ　コンテナ化されたアプリケーションを保護する要素技術 ](https://www.amazon.co.jp/%E3%82%B3%E3%83%B3%E3%83%86%E3%83%8A%E3%82%BB%E3%82%AD%E3%83%A5%E3%83%AA%E3%83%86%E3%82%A3-%E3%82%B3%E3%83%B3%E3%83%86%E3%83%8A%E5%8C%96%E3%81%95%E3%82%8C%E3%81%9F%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%82%92%E4%BF%9D%E8%AD%B7%E3%81%99%E3%82%8B%E8%A6%81%E7%B4%A0%E6%8A%80%E8%A1%93-Liz-Rice/dp/4295016403)
[3] [コンテナと VM](https://www.redhat.com/ja/topics/containers/containers-vs-vms)
[4] [docker hub](https://hub.docker.com/)
[5] [docker hub クラウドネイティブなソフトウェアの導入を簡単に](https://www.docker.com/ja-jp/products/docker-hub/)
[6] [dockerが使うUnionFileSystemを僕なりに解釈した](https://namu-r21.hatenablog.com/entry/2016/10/27/013006)
[7] []()
[8] []()
[9] []()
