# Dockerを完全に理解する


こんにちは、しぶやです。\
学生時代の研究から始まり、社会人になってからも愛用しているDockerについて、気合をいれてまとめようと思います。

## TL;DR

*
*
*

## 0　はじめに

### 0.1　コンテナの歴史

### 0.2　VMとの違い

### 0.3　近年の傾向

## 1　コンテナの仕組み

### 1.1　namespace

NamespaceはLinuxカーネルに組み込まれたプロセス単位でリソースを分離する機能です。
具体的には、特定のプロセスに対し、ネットワークインターフェースを見せたり、ピロセスID空間を見せたりできます。

linuxでサポートされているNamespaceには以下のよいなものがあります。
名
名前
分離対象
説明
Mount (mnt)
ファイルシステムのマウント状態
それぞれ別のルートディレクトリ構造を持てる
UTS
ホスト名、ドメイン名
各Namespaceごとにホスト名が持てる
IPC
プロセス間通信（共有メモリなど）
通信空間を隔離できる
PID
プロセスID
プロセスID空間が分かれる
Network
ネットワークデバイス、IPアドレス
独立したネットワークスタック
User
ユーザID、グループID
プロセスに別のUID/GIDマッピング
Cgroup
cgroupのビュー
制御グループの空間を分離

では、実際にNamespaceを見てみましょう。

lsns

unshare utsコマンド

"unshare"コマンドは新しいNamespaceでプログラムを実行できます。
すなわち、親プロセスである現在のshell(私の場合はzsh)からNamespaceを継承せずに子プロセスを作成することができます。

今回の例では、新しいUTS Namespaceを持つshellのプロセスを作成しています。
この場合、新しく作成したプロセス内でhostnameを変更しても、shellが認識しているUTS Namespaceとホスト側の
が認識していUTS Namespaceが異なるため、ホスト側からhostnameコマンドを打っても特に変化はありません。

unshare psコマンド

プロセスID空間を分離していますが、ホストのプロセス全体が見えています。
これは、psコマンドは/procを見てるだけだからです。
ホストからpsコマンドでアクセスする際と何も変わりません。

コンテナの動きを考えると、プロセスID空間が分離され、新しいプロセスからは何も見えない状況となって欲しいところです。
これを実現するには、1.3のchrootを利用する必要があります。

### 1.2　cgroup

CgroupはLinuxカーネルに組み込まれたプロセス単位でリソースを監視/制御する機能です。
具体的には以下のようなことができます。

* リソース使用量のモニタリング
* CPU使用率の制限
* メモリ使用量の制限
* ディスクI/O帯域の制限
* ネットワーク帯域の制限

Cgroupはプロセスをグループにまとめたプロセスグループを作成し、リソース管理のルールを適用することでリソース使用量の管理／制御を行います。

Dockerはコンテナ単位でCgroupのグループを作成し、リソース使用量を管理しているのです！

それでは実際にCgroupを見ていきましょう。

/sys/fs/cgroupの写真

Linuxカーネルは/sys/fs/cgroupに擬似ファイルシステムを作成し、Cgroupに関連する情報を提供します。

tip 擬似ファイルシステムとは

擬似ファイルシステムとは、実際にファイルのようにカーネル内部の情報にアクセスできるようにする仕組みです。
実際にディスク内部にデータを保存しているわけではなく、リアルタイムにカーネルが情報を生成して応答してくれています。
カーネルAPIみたいな感じですね、

Linuxの擬似ファイルシステムのは以下のようなものがあります。
* /proc\
プロセス情報やシステム情報をふぁいるけいしきで提供
* /sys\
デバイスやカーネル内部設定の情報/操作をファイル形式で提供
* /dev\
デバイスファイル

一例挙げる


cgroup実践




docker起動時のcgroupの確認

メモリ
cpu
process


### 1.3　chroot/rootfs

chrootはrootディレクトリを変更するコマンドです。
chrootは引数にパスとコマンドを受け取ります。
これにより、指定したパスをルートとして、コマンドを実行します。
ここで、注意が必要なのは、コマンド自身もルートより上位のファイルにはアクセスできなくなります。
すなわち、ルートとして指定したパスの配下にコマンド実行に必要なファイルが一式必要です。

実際に、適当なコマンドで試してみましょう。


配下にechoの実行ファイルがないため、エラーになります。

では、よりdockerを意識してalpineのパッケージを使って試してみましょう。

配下にalpineのパッケージが一式あるため、コマンドを実行できます。
shを実行してみるとルートより上には上がれず、一式のファイルがあるため仮想環境のように感じます。
まさにDockerでコンテナを立てたときのようですね！
＊ chroot時はホストの環境変数は引き継がれ、$pathなどはルートとして設定された位置を起点に検索が行われます。

tip 環境変数
chrootではホストの環境変数が引き継がれていましたが、dockerで立てたコンテナではホストとは隔離されて別の環境変数が利用できます。
これはどのように実現されているのでしょうか？

これを理解するためには、そもそも環境変数の理解が必要です。
実は、環境変数の実体はメモリ上に保存されており、プロセスごとに保持しています。

プロセスがもつ環境変数の例
/proc/$$/environ

のプロセスが環境変数を持っていることが分かります。

確認したように、環境変数はプロセスごとに保持してお、プロセスは他プロセスの環境変数にアクセスすることはできません。
子プロセスは親プロセスの環境変数を引き継ぎ、親プロセスの環境変数のは影響を与えずに自身の環境変数を変更できます。

dockerなどでは、コンテナを生成する際にメインプロセスに引数やDockerfike、コンテナイメージから受け取った環境変数を付与し、コンテナを立ち上げます。


1.1との組み合わせ。


### 1.4　コンテナの本質
コンテナはプロセス。
initプロセスとPID
ホストから見たとき

## 2　Dockerイメージ

### 2.1　Docker Hub

### 2.2　イメージの構成

Layerの階層構造
再利用性
Union FS


### 2.3　最小化

scratch, Alpine, distroless
思想
attack surfaceの削減
運用

## 3　コンテナセキュリティ

### 3.1　capability

管理者権限を与えずに、最小権限の原則に則り、動作に必要な権限のみを与えるやつです。
以下は「Linuxのアクセス制御を完全に理解する」からの抜粋です。

>

基本的なアクセス制御から復習したい方は「Linuxのアクセス制御を完全に理解する」をお勧めします！

### 3.2　コンテナroot

コンテナ内のrootは？
ユーザ変える必要ある？
--privileged

### 3.3　イメージ

信頼性
Docker Content Trust

## 4　Dockerのユースケースとアーキテクチャ

### 4.1　CI/CD


### 4.2　Kubernetes

### 4.3　環境統一


## 5　Dockerのメリット/デメリット

### 5.1　メリット

環境構築の迅速化
環境の再現性と移植性
リソースの軽量性
ホストを汚さない
アタックサーフェスの削減

### 5.2　デメリット

セキュリティ境界の脆弱性
ホスト依存の可能性
オーバーヘッド

## 6　まとめ

kubernetes thread model
kunernetes atacck tree

## 参考

[1] [docker](https://www.docker.com/)
[2] [コンテナセキュリティ　コンテナ化されたアプリケーションを保護する要素技術 ](https://www.amazon.co.jp/%E3%82%B3%E3%83%B3%E3%83%86%E3%83%8A%E3%82%BB%E3%82%AD%E3%83%A5%E3%83%AA%E3%83%86%E3%82%A3-%E3%82%B3%E3%83%B3%E3%83%86%E3%83%8A%E5%8C%96%E3%81%95%E3%82%8C%E3%81%9F%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%82%92%E4%BF%9D%E8%AD%B7%E3%81%99%E3%82%8B%E8%A6%81%E7%B4%A0%E6%8A%80%E8%A1%93-Liz-Rice/dp/4295016403)

