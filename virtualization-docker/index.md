# Dockerを完全に理解する


こんにちは、しぶやです。\
学生時代の研究から始まり、社会人になってからも愛用しているDockerについて、気合をいれてまとめようと思います。


## TL;DR

*
*
*

## 0　はじめに

### 0.1　コンテナの歴史

コンテナ技術の初期段階として、2008年ごろLXC（Linux Container）が登場しました。
LXCは、2000年代に入ってLinuxに導入されたNamespaceやCgroupsを利用した軽量なコンテナ環境を提供するものです。

その後、2013年ごろ、Dockerが登場し、コンテナ技術が広く知られるようになりました。
DockerはLXCをもとに、コンテナの作成、管理、デプロイを非常に簡単にするツールとして登場しました。
Dockerの登場により、コンテナは非常に使いやすいものとなり、仮想マシンに代わる新しい標準として急速に普及しました。

※ Dockerはあくまでコンテナを管理するためのツールであり、Docker=コンテナではないです。

公式ではDockerを以下のように説明しています。
> Docker は、アプリケーションの開発、出荷、実行の方法に革命をもたらした包括的なプラットフォームとツールスイートを提供します。
> コンテナ化の概念に基づいて構築されており、コンテナの代名詞になるほど単純化されています。

コンテナという意味では近年、Kubernetesにより大規模な分散システムの基盤として使用されたり、サーバーレスコンピューティングに応用されていたりします。

### 0.2　VMとの違い

VMとコンテナの違いはよく聞く話だと思います。
[よくある説明](https://www.redhat.com/ja/topics/containers/containers-vs-vms)は、ホストOS上に新たにOSを乗せるているかとホストOS上にコンテナとして隔離されたアプリケーションを乗せているかです。

この説明の通り、**VMとコンテナの違いはホストのカーネルを共有するか**です。
VMはホストOS上でカーネルを仮想化を行います。
一方で、コンテナはホストのカーネルを共有し、リソースなどを分離します。

これにより、コンテナは**軽量なアプリケーションの実行環境**を実現します。

tip ハイパーバイザのタイプ
コンテナから話がそれますが、ハイパーバイザーとそのタイプについて紹介します。

まずは、そもそものハイパーバイザーの定義を見てみましょう。
> ハイパーバイザー (hypervisor) とは、仮想化技術であり、必要なコンピューティング・リソースを分離し、仮想マシン(VM)の作成、実行、管理を可能にするソフトウェアです。ハイパーバイザーは、演算処理、メモリー、ストレージなどのコンピューティング・リソースをプールし、それらを仮想マシン (VM) 間で再割り当てします。このテクノロジーによって仮想化が可能になり、1 つの物理マシンから多数の VM を作成して実行することができます。
> by [redhat](https://www.redhat.com/ja/topics/virtualization/what-is-a-hypervisor)

一般的にもよく使われるものでいうと、VMware Workstationや VirtualBoxがありますね。
商用で見るもだとVMware ESXiやKVMなどがありますね。

これらのハイパーバイザーは大きく以下の2種類に分けられます。
| 項目 | タイプ1 | タイプ2 |
|-----|--------|-------|
| 実行権限 | 直接 | 間接(ホストOS経由) |
| 制御主体 | ハイパーバイザー自身 | ホストOS |
| 安全性・効率 | 高い | 低い　|

結局ハイパーバイザーもOSみたいなものが動いているんだから何が違うんだ？って感じです。
ChatGPTによると、「仮想化機能だけを持った(それに特化した)制御ソフト」か「汎用OSで制御ソフトを動かしている」かの違いで区別できるようです。
これは、「カーネルの一部として動作」か「ユーザ空間のアプリケーションとして動作する」かの違いとも言えそうです。

上記の表にある安全性や効率に関しては、タイプ1が「余計なものを動かしていない」ことや「余計なものが含まれていない」ことから来るもののようです。
参考書[1]によると、Linuxカーネルは2000万行以上のコードがあるのに対し、Xenは5万行程度らしいです。

有名な製品をタイプ1とタイプ2で分けると以下のようになります。
* タイプ1\
  * VWware ESXi
  * Microsoft Hyper-V
  * Xen
  * KVM
* タイプ2\
  * VMware Workstation/Fusion
  * VirtualBox
  * Parallel Desktop

※ KVMやHyper-Vは汎用OS上で、Kernelを拡張してVMを動かすため、タイプ2という意見もあるようです。

## 1　コンテナの仕組み

コンテナにはいくつかの欠かせない要素技術があります。
本章では、コンテナの本質を理解するために、それらの要素技術について学習しようと思います。

### 1.1　namespace

NamespaceはLinuxカーネルに組み込まれたプロセス単位でリソースを分離する機能です。
具体的には、特定のプロセスに対し、ネットワークインターフェースを見せたり、プロセスID空間を見せたりできます。

linuxでサポートされているNamespaceには以下のよいなものがあります。
|名前 | 分離対象 | 説明|
|-----------|-------|-----|
|Mount (mnt) | ファイルシステムのマウント状態 | それぞれ別のルートディレクトリ構造を持てる|
|UTS|ホスト名、ドメイン名|各Namespaceごとにホスト名が持てる|
|IPC|プロセス間通信（共有メモリなど）|通信空間を隔離できる|
|PID|プロセスID|プロセスID空間が分かれる|
|Network|ネットワークデバイス、IPアドレス|独立したネットワークスタック|
|User|ユーザID、グループID|プロセスに別のUID/GIDマッピング|
|Cgroup|cgroupのビュー|制御グループの空間を分離|

では、実際にNamespaceを見てみましょう。

{{< image src="lsns.png" width="800px" height="600px" caption="Namespaceの一覧" >}}

lsnsはNamespaceを表示するためのコマンドです。
TYPEが上で紹介したNamespaceの種類です。
NPROCSはそのNamespaceに所属するプロセス数、PID以降は親プロセスの情報です。

ここで、"sudo lsns"と"lsns"で表示されているNamespaceの数が違うことが分かります。

これは、rootでしかアクセスできないプロセスがいるためです。
よく見るとNPROCSの値も異なることが解ると思います。
Namespaceの情報は各プロセスが持つので、ユーザでは一部のNamespaceの所属するすべてのプロセスが見えず、Namespaceを確認することができないのです。

実際に、/proc配下のアクセス権限を見るとユーザではみれないものがいることが分かります。
（Linuxではプロセス情報はLinuxカーネルが提供する/procから取得しています。）

{{< image src="proc-visibility.png" width="800px" height="600px" caption="/procのアクセス権" >}}


{{< image src="uts.png" width="800px" height="600px" caption="UTS Namespaceの分離" >}}

"unshare"コマンドは新しいNamespaceでプログラムを実行できます。
すなわち、親プロセスである現在のshell(私の場合はzsh)からNamespaceを継承せずに子プロセスを作成することができます。

今回の例では、新しいUTS Namespaceを持つshellのプロセスを作成しています。
この場合、新しく作成したプロセス内でhostnameを変更しても、shellが認識しているUTS Namespaceとホスト側の
が認識していUTS Namespaceが異なるため、ホスト側からhostnameコマンドを打っても特に変化はありません。

{{< image src="pid.png" width="800px" height="600px" caption="PID Namespaceの分離" >}}

プロセスID空間を分離していますが、ホストのプロセス全体が見えています。
これは、psコマンドは/procを見てるだけだからです。
ホストからpsコマンドでアクセスする際と何も変わりません。

コンテナの動きを考えると、プロセスID空間が分離され、新しいプロセスからは何も見えない状況となって欲しいところです。
これを実現するには、1.3のchrootを利用する必要があります。

{{< image src="mount.png" width="800px" height="600px" caption="mount Namespaceの分離" >}}

mount namespaceはプロセスにファイルシステムのマウントポイントをバインドし実行するコマンドです。
そもそもプロセスへのマウントとは何でしょうか？
Linuxにおいて各プロセスはファイルシステムのマウントポイントを持っています。
通常は全て同じ"/"がマウントポイントとしてバインドされているはずです。
これは、/proc/${pid}/mountsで見ることができます。

{{< image src="proc-mounts.png" width="800px" height="600px" caption="プロセスのマウント情報" >}}

プロセスごとにマウントポイントを持っていることが分かります。

Dockerでは、このmount namespaceの分離と1.3で説明するchrootを組み合わせてコンテナ領域の分離を行っています。

lsns -t netの写真

Network Namespaceはネットワークインターフェースやルーティングテーブルの分離を行います。
実際に見てみしょう。

unshare --netの写真

これだけでは、仮想インターフェースがなく、ホストと通信ができません。
ホストと通信できるようにします。

ip link
ip link set

これでホストとコンテナが通信できるようになりました。
このように、Network NamespaceではNICとルーティングテーブルを分離することができます。

続いては、User Namespaeです。User Namespaceはプロセスごとにユーザやグループの分離を行います。

新たなUsername Namespaceを作成してみましょう。

{{< image src="user.png" width="800px" height="600px" caption="a" >}}
{{< image src="user-1.png" width="800px" height="600px" caption="a" >}}
{{< image src="user-2.png" width="800px" height="600px" caption="a" >}}
{{< image src="user-3.png" width="800px" height="600px" caption="a" >}}
{{< image src="capsh.png" width="800px" height="600px" caption="a" >}}

新しいUser Namespaceを作成するとユーザはnobodyになります。
ここでホストのユーザとのマッピングを行うのです。


残りはIPC NamespaceとCgroup Namespaceです。

IPC Namespaceは、プロセス間通信を行うために利用されます。
Dockerではコンテナ同士に同じIPC Namespaceを割り当てることで互いに共有メモリにアクセスできるようにします。

{{< image src="ipcs.png" width="800px" height="600px" caption="a" >}}

Cgroup Namespaceは1.2節で説明するCgroupについて、Cgroupの見える範囲を分離します。
これにより、プロセスは上位のリソース構成を覗けず、独立して動いているように見えます。

{{< image src=cgroup.png" width="800px" height="600px" caption="a" >}}



### 1.2　cgroup

CgroupはLinuxカーネルに組み込まれたプロセス単位でリソースを監視/制御する機能です。
具体的には以下のようなことができます。

* リソース使用量のモニタリング
* CPU使用率の制限
* メモリ使用量の制限
* ディスクI/O帯域の制限
* ネットワーク帯域の制限

Cgroupはプロセスをグループにまとめたプロセスグループを作成し、リソース管理のルールを適用することでリソース使用量の管理／制御を行います。

Dockerはコンテナ単位でCgroupのグループを作成し、リソース使用量を管理しているのです！

それでは実際にCgroupを見ていきましょう。

/sys/fs/cgroupの写真

Linuxカーネルは/sys/fs/cgroupに擬似ファイルシステムを作成し、Cgroupに関連する情報を提供します。

tip 擬似ファイルシステムとは

擬似ファイルシステムとは、実際にファイルのようにカーネル内部の情報にアクセスできるようにする仕組みです。
実際にディスク内部にデータを保存しているわけではなく、リアルタイムにカーネルが情報を生成して応答してくれています。
カーネルAPIみたいな感じですね、

Linuxの擬似ファイルシステムのは以下のようなものがあります。
* /proc\
プロセス情報やシステム情報をふぁいるけいしきで提供
* /sys\
デバイスやカーネル内部設定の情報/操作をファイル形式で提供
* /dev\
デバイスファイル


cgroup実践




### 1.3　chroot/rootfs

chrootはrootディレクトリを変更するコマンドです。
chrootは引数にパスとコマンドを受け取ります。
これにより、指定したパスをルートとして、コマンドを実行します。
ここで、注意が必要なのは、コマンド自身もルートより上位のファイルにはアクセスできなくなります。
すなわち、ルートとして指定したパスの配下にコマンド実行に必要なファイルが一式必要です。

実際に、適当なコマンドで試してみましょう。

{{< image src="chroot-1.png" width="800px" height="600px" caption="chroot" >}}

配下にbashの実行ファイルがないため、エラーになります。

では、よりdockerを意識してalpineのパッケージを使って試してみましょう。

{{< image src="chroot-2.png" width="800px" height="600px" caption="chroot" >}}

配下にalpineのパッケージが一式あるため、コマンドを実行できます。
shを実行してみるとルートより上には上がれず、一式のファイルがあるため仮想環境のように感じます。
まさにDockerでコンテナを立てたときのようですね！
＊ chroot時はホストの環境変数は引き継がれ、$pathなどはルートとして設定された位置を起点に検索が行われます。

tip 環境変数
chrootではホストの環境変数が引き継がれていましたが、dockerで立てたコンテナではホストとは隔離されて別の環境変数が利用できます。
これはどのように実現されているのでしょうか？

これを理解するためには、そもそも環境変数の理解が必要です。
実は、環境変数の実体はメモリ上に保存されており、プロセスごとに保持しています。

プロセスがもつ環境変数の例
{{< image src="environ.png" width="800px" height="600px" caption="プロセスがもつ環境変数" >}}

のプロセスが環境変数を持っていることが分かります。

確認したように、環境変数はプロセスごとに保持してお、プロセスは他プロセスの環境変数にアクセスすることはできません。
子プロセスは親プロセスの環境変数を引き継ぎ、親プロセスの環境変数のは影響を与えずに自身の環境変数を変更できます。

dockerなどでは、コンテナを生成する際にメインプロセスに引数やDockerfike、コンテナイメージから受け取った環境変数を付与し、コンテナを立ち上げます。


### 1.4　コンテナの本質

「結局コンテナってら何なの？」と言われた時に何て答えましょう？
個人的には、参考書[1]にあった「コンテナ」=「コンテナ化されたプロセス」という表現がしっくりきています。
「Linuxのプロセスをリソースやアクセスできる空間などを分離した上で動かしたもの」がコンテナと言えそうです。

## 2　コンテナイメージ

### 2.1　イメージ管理

コンテナレジストリとは、コンテナイメージ全体の保管サーバです。
代表的なレジストリには以下があります。
* Docker Hub...Docker者が運営する、最も有名なパブリックレジストリ
* Github Container Registry...Githubが提供するコンテナレジストリ
* Amazon ECR...AWSが提供するマネージドなレジストリ（AzureやGCPも同様）

コンテナレジストリに対し、レジストリ内の特定の名前空間/プロジェkとごと保存単位をレポジトリと呼びます。
Docker Hubにある公式の"nginx:latest"を例にするとDocker Hubがレジストリであり、nginxがレポジトリ名です。

ここでは、Dockerでデフォルトで利用されるDocker Hubについて調査します。

[Docker Hub](https://www.docker.com/ja-jp/products/docker-hub/)はコンテナ化されたアプリを簡単に保存、管理、デプロイするためのプラットフォームです。
Docker Hubの機能には以下のようなものがあります。
* 無制限のパブリックリポジトリ...無制限のパブリックなリポジトリを利用できます。誰かが作成したカスタムイメージなどもすぐに利用できます。
* プライベート リポジトリ...プライベートリポジトリを作成し、イメージへのアクセス制御を行うことができます。
* 効率的なイメージアクセス...コンテナイメージへの効率的なアクセスと配布をサポート
* Webhook...イメージのプッシュなどのイベントをトリガーに外部に通知を送ることができます。これにより、Docker HubのCI/CDパイプラインとの統合を可能にします。
* 自動テスト...コンテナイメージで自動テストを実行し、問題を早期に発見することができます。
* GitHubとBitbucketの統合...Githubなどと統合し、バージョン管理システムからの直接ビルドと導入を自動化します。
* 同時ビルドと自動ビルド...複数のビルドを同時に実行することができます。


### 2.2　イメージの構成

Layerの階層構造
再利用性
Union FS


### 2.3　最小化

scratch, Alpine, distroless
思想
attack surfaceの削減
運用

## 3　Docker実践

### 3.1　イメージ管理

pullしたときの通信。
どこに保存されるのか。

Dockerfileとビルドしたときのレイヤー

### 3.2　コンテナプロセス

コンテナ実行時のプロセス
cgroupだったり

## 4　コンテナセキュリティ

### 4.1　capability

管理者権限を与えずに、最小権限の原則に則り、動作に必要な権限のみを与えるやつです。
以下は「Linuxのアクセス制御を完全に理解する」からの抜粋です。

>

基本的なアクセス制御から復習したい方は「Linuxのアクセス制御を完全に理解する」をお勧めします！

### 4.2　コンテナroot

コンテナ内のrootは？
ユーザ変える必要ある？
--privileged

### 4.3　イメージ

信頼性
Docker Content Trust

## 5　Dockerのユースケースとアーキテクチャ

### 5.1　CI/CD


### 5.2　Kubernetes

### 5.3　環境統一


## 6　Dockerのメリット/デメリット

本章ではDockerのメリットやデメリットを主にVMと比較したときの観点で紹介していきます。

### 6.1　メリット

* 軽量性\
コンテナはあくまでプロセスにすぎません。
VMのやうにハードウェアをエミュレートしたり、ゲスト用に新たなカーネルを動作させたりもしません。
これにより、専用にVMを立ててアプリケーションを動かす場合と比較し、軽量に動作させることができます。
また、起動時間が非常に短いことも大きなメリットと言えます。

* 再現性/移行性\
コンテナは自身のパッケージ群を持っています。
すなわち、Dockerfileと参照するイメージが同じであれば、いつでもパッケージ群でプロセスが動くということです。
これにより、開発者は開発環境が違っても同じアプリケーション環境での開発、デプロイを実現することができます。

* 環境構築の迅速化\
コンテナはDocker Hubなどを通して非常に多くのイメージが展開されています。
また、追加のパッケージ等もDockerfileにコードとして記載することで容易にインストールできます。
これにより、VMを立てて必要なパッケージをインストール/設定していく場合と比較し、より迅速に環境構築を行うことができると言えます。

* リソースの節約\
VM単位でリソースを確保せず、アプリケーション単位でリソースを確保できるためリソースの節約になる可能性があります。
具体的には、クラウドでのコンテナ利用があります。
VMで固定のリソースを確保した場合は、実際にリソースを利用していなくても課金されますが、コンテナであれば使ったリソース分のみの課金ですみます。

* ホストを汚さない\
これは、個人的に大きなメリットだと持っている点です。
Dockerfileはいつでも同じものを作れる設計書です。
リソースを外から取ってこれる場合は、テキストファイルのみあれば、いつでもすぐに同じ環境を作れます。
これは、ホスト環境も汚れずにストレージ容量も取らないため検証用の環境だったりを手元に保管しておくうえで非常に便利です。

* アタックサーフェスの縮小
アプリケーションをコンテナとして必要最小限の権限のみをつけて実行することで、アタックサーフェスを縮小できます。
コンテナは様々なリソースを分離し、必要なcapabilityのみを持たせることで、攻撃対象を縮小するだけでなく、攻撃を受けた際の影響を抑えてくれます。
アプリケーションユーザも変えずに何でもかんでもsudoでアプリケーションを動かす場合と比較し、非常に堅牢であると言えます。

### 6.2　デメリット

セキュリティ境界の脆弱性
ホスト依存の可能性
オーバーヘッド

## 7　まとめ

kubernetes thread model
kunernetes atacck tree

hoge

## 参考

[1] [docker](https://www.docker.com/)
[2] [コンテナセキュリティ　コンテナ化されたアプリケーションを保護する要素技術 ](https://www.amazon.co.jp/%E3%82%B3%E3%83%B3%E3%83%86%E3%83%8A%E3%82%BB%E3%82%AD%E3%83%A5%E3%83%AA%E3%83%86%E3%82%A3-%E3%82%B3%E3%83%B3%E3%83%86%E3%83%8A%E5%8C%96%E3%81%95%E3%82%8C%E3%81%9F%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%82%92%E4%BF%9D%E8%AD%B7%E3%81%99%E3%82%8B%E8%A6%81%E7%B4%A0%E6%8A%80%E8%A1%93-Liz-Rice/dp/4295016403)
[3] [コンテナと VM](https://www.redhat.com/ja/topics/containers/containers-vs-vms)
[4] [docker hub](https://hub.docker.com/)
[5] [docker hub クラウドネイティブなソフトウェアの導入を簡単に](https://www.docker.com/ja-jp/products/docker-hub/)
[6] [dockerが使うUnionFileSystemを僕なりに解釈した](https://namu-r21.hatenablog.com/entry/2016/10/27/013006)
[7] []()
[8] []()
[9] []()

